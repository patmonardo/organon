import { DegreePartition } from './DegreePartition';
import { DegreeFunction } from './PartitionUtils';
import { Concurrency } from '../../../concurrency/Concurrency';
import { BitUtil } from '../../../mem/BitUtil';

/**
 * Base class for iterators that lazily generate degree partitions.
 */
export abstract class LazyDegreePartitionIterator implements Iterator<DegreePartition> {
  // This is a good guess to achieve smaller partitions
  private static readonly DIVISION_FACTOR = 10;

  /**
   * Returns an array of all degree partitions.
   * 
   * @returns Array of degree partitions
   */
  public toArray(): DegreePartition[] {
    const result: DegreePartition[] = [];
    let next: IteratorResult<DegreePartition>;
    
    while (!(next = this.next()).done) {
      result.push(next.value);
    }
    
    return result;
  }

  /**
   * Returns an iterable for this iterator.
   * 
   * @returns Iterable of degree partitions
   */
  public asIterable(): Iterable<DegreePartition> {
    return {
      [Symbol.iterator]: () => this
    };
  }

  /**
   * Gets the next degree partition.
   * 
   * @returns Next partition or done
   */
  public abstract next(): IteratorResult<DegreePartition>;

  /**
   * Creates a new lazy degree partition iterator.
   * 
   * @param nodeCount Total number of nodes
   * @param relationshipCount Total number of relationships
   * @param concurrency Concurrency level
   * @param degrees Function to get node degrees
   * @returns New iterator
   */
  public static of(
    nodeCount: number,
    relationshipCount: number,
    concurrency: Concurrency,
    degrees: DegreeFunction
  ): LazyDegreePartitionIterator {
    const numRelationshipsInPartition = BitUtil.ceilDiv(
      relationshipCount,
      concurrency.value() * LazyDegreePartitionIterator.DIVISION_FACTOR
    );

    return new MultiDegreePartitionIterator(nodeCount, numRelationshipsInPartition, degrees);
  }
}

/**
 * Implementation of LazyDegreePartitionIterator that creates multiple partitions.
 */
class MultiDegreePartitionIterator extends LazyDegreePartitionIterator {
  private readonly nodeCount: number;
  private readonly degrees: DegreeFunction;
  private readonly partitionSize: number;
  
  private nextStartNode: number;
  private done: boolean;

  /**
   * Creates a new multi-degree partition iterator.
   * 
   * @param nodeCount Total number of nodes
   * @param partitionSize Target size of each partition in relationships
   * @param degrees Function to get node degrees
   */
  constructor(
    nodeCount: number,
    partitionSize: number,
    degrees: DegreeFunction
  ) {
    super();
    this.nodeCount = nodeCount;
    this.degrees = degrees;
    this.partitionSize = partitionSize;
    this.nextStartNode = 0;
    this.done = false;
  }

  /**
   * Gets the next degree partition.
   * 
   * @returns Next partition or done
   */
  public next(): IteratorResult<DegreePartition> {
    if (this.done) {
      return { done: true, value: undefined };
    }

    let nodeId = this.nextStartNode;

    if (nodeId >= this.nodeCount) {
      this.done = true;
      return { done: true, value: undefined };
    }

    let relsInPartition = 0;
    const startNode = nodeId;

    for (; nodeId < this.nodeCount; nodeId++) {
      const nextRelationshipCount = this.degrees(nodeId);

      relsInPartition += nextRelationshipCount;
      if (relsInPartition > this.partitionSize) {
        this.nextStartNode = nodeId + 1;
        return { 
          done: false, 
          value: DegreePartition.of(
            startNode,
            this.nextStartNode - startNode,
            relsInPartition
          ) 
        };
      }
    }

    this.nextStartNode = nodeId + 1;
    this.done = true;
    
    return { 
      done: false, 
      value: DegreePartition.of(
        startNode, 
        this.nodeCount - startNode, 
        relsInPartition
      ) 
    };
  }

  /**
   * Creates an array from all partitions generated by this iterator.
   * 
   * @returns Array of degree partitions
   */
  public override toArray(): DegreePartition[] {
    const result: DegreePartition[] = [];
    let nodeId = 0;
    
    while (nodeId < this.nodeCount) {
      let relsInPartition = 0;
      const startNode = nodeId;
      
      for (; nodeId < this.nodeCount; nodeId++) {
        const nextRelationshipCount = this.degrees(nodeId);
        
        relsInPartition += nextRelationshipCount;
        if (relsInPartition > this.partitionSize) {
          nodeId++;
          break;
        }
      }
      
      result.push(DegreePartition.of(
        startNode,
        nodeId > this.nodeCount ? this.nodeCount - startNode : nodeId - startNode,
        relsInPartition
      ));
    }
    
    return result;
  }
}