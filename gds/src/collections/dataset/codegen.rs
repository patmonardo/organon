//! Rust DSL module code generation from dataset compilation artifacts.

use crate::collections::dataset::catalog_index::DatasetCatalogIndex;
use crate::collections::dataset::compile_ir::{DatasetCompilation, DatasetNodeKind};

#[derive(Debug, Clone)]
pub struct DslCodegenOptions {
    pub module_name: String,
    pub include_public_exports: bool,
}

impl Default for DslCodegenOptions {
    fn default() -> Self {
        Self {
            module_name: "generated_dataset_dsl".to_string(),
            include_public_exports: true,
        }
    }
}

pub fn render_rust_dsl_module(
    compilation: &DatasetCompilation,
    index: &DatasetCatalogIndex,
    options: &DslCodegenOptions,
) -> String {
    let mut out = String::new();

    out.push_str("// @generated by dataset DSL compiler utilities\n");
    out.push_str(
        "// This file is intended as a deterministic scaffold for iterative refinement.\n\n",
    );
    out.push_str(&format!("pub mod {} {{\n", options.module_name));
    out.push_str("    #[derive(Debug, Clone)]\n");
    out.push_str("    pub struct NodeSpec {\n");
    out.push_str("        pub id: &'static str,\n");
    out.push_str("        pub name: &'static str,\n");
    out.push_str("        pub kind: &'static str,\n");
    out.push_str("        pub depends_on: &'static [&'static str],\n");
    out.push_str("    }\n\n");

    out.push_str("    pub const NODES: &[NodeSpec] = &[\n");
    for node in compilation.nodes.values() {
        let kind_name = match node.kind {
            DatasetNodeKind::Model => "model",
            DatasetNodeKind::Feature => "feature",
            DatasetNodeKind::Frame => "frame",
            DatasetNodeKind::Series => "series",
            DatasetNodeKind::Expr => "expr",
            DatasetNodeKind::Function => "function",
            DatasetNodeKind::Macro => "macro",
        };

        out.push_str("        NodeSpec {\n");
        out.push_str(&format!("            id: \"{}\",\n", node.id));
        out.push_str(&format!("            name: \"{}\",\n", node.name));
        out.push_str(&format!("            kind: \"{}\",\n", kind_name));
        out.push_str("            depends_on: &[");
        for (idx, dep) in node.depends_on.iter().enumerate() {
            if idx > 0 {
                out.push_str(", ");
            }
            out.push_str(&format!("\"{}\"", dep));
        }
        out.push_str("],\n");
        out.push_str("        },\n");
    }
    out.push_str("    ];\n\n");

    out.push_str("    pub const ENTRYPOINTS: &[&str] = &[");
    for (idx, entrypoint) in compilation.entrypoints.iter().enumerate() {
        if idx > 0 {
            out.push_str(", ");
        }
        out.push_str(&format!("\"{}\"", entrypoint));
    }
    out.push_str("];\n\n");

    out.push_str("    pub fn node_count() -> usize { NODES.len() }\n");
    out.push_str("    pub fn entrypoint_count() -> usize { ENTRYPOINTS.len() }\n");

    if options.include_public_exports {
        out.push_str("\n    pub fn groups() -> &'static [(&'static str, usize)] {\n");
        out.push_str("        &[\n");
        for kind in index.all_kinds() {
            let group_name = match kind {
                DatasetNodeKind::Model => "model",
                DatasetNodeKind::Feature => "feature",
                DatasetNodeKind::Frame => "frame",
                DatasetNodeKind::Series => "series",
                DatasetNodeKind::Expr => "expr",
                DatasetNodeKind::Function => "function",
                DatasetNodeKind::Macro => "macro",
            };
            let count = index.nodes_of_kind(compilation, kind).len();
            out.push_str(&format!("            (\"{}\", {}),\n", group_name, count));
        }
        out.push_str("        ]\n");
        out.push_str("    }\n");
    }

    out.push_str("}\n");
    out
}
