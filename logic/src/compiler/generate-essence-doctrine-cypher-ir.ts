import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import type { TopicMapEntry } from '@schema/topic';
import {
  IntegratedTopicMapIRSchema,
  type IntegratedTopicChunk,
  type IntegratedTopicMapIR,
  type IntegratedTopicTrace,
  type IntegratedTopicTraceType,
  type DialecticalMoment,
  type ConsciousnessDoctrine,
} from '@schema/integrated-topic-ir';
import { essenceTopicMap } from '@relative/essence/reflection/essence/sources/essence-topic-map';
import { reflectionTopicMap } from '@relative/essence/reflection/essence/sources/reflection-topic-map';
import { shineTopicMap } from '@relative/essence/reflection/essence/sources/shine-topic-map';
import { identityTopicMap } from '@relative/essence/reflection/foundation/sources/identity-topic-map';
import { differenceTopicMap } from '@relative/essence/reflection/foundation/sources/difference-topic-map';
import { contradictionTopicMap } from '@relative/essence/reflection/foundation/sources/contradiction-topic-map';

type SourceSpec = {
  id: string;
  title: string;
  sourceFile: string;
  topicMap: TopicMapEntry[];
};

function cypherEscape(value: string): string {
  return value
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/\r/g, '\\r')
    .replace(/\n/g, '\\n');
}

function toCypherString(value: string): string {
  return `'${cypherEscape(value)}'`;
}

function toCypherArray(values: string[]): string {
  return `[${values.map(toCypherString).join(', ')}]`;
}

function extractChunkText(
  sourceText: string,
  lineRange: { start: number; end: number },
): string {
  const lines = sourceText.split(/\r?\n/);
  return lines
    .slice(lineRange.start - 1, lineRange.end)
    .join('\n')
    .trim();
}

function inferDialecticalRole(
  entry: TopicMapEntry,
  sourceText: string,
): DialecticalMoment {
  const body =
    `${entry.title} ${entry.description} ${entry.keyPoints.join(' ')} ${sourceText}`.toLowerCase();

  let intuitiveScore = 0;
  let conceptualScore = 0;
  let reflectiveScore = 1;

  const intuitiveSignals = [
    'intuition',
    'immediate',
    'sensibility',
    'perception',
  ];
  const conceptualSignals = [
    'concept',
    'determination',
    'judgment',
    'universal',
  ];
  const reflectiveSignals = [
    'negation',
    'sublation',
    'reflection',
    'essence',
    'movement',
    'shine',
  ];

  for (const signal of intuitiveSignals) {
    if (body.includes(signal)) intuitiveScore += 1;
  }

  for (const signal of conceptualSignals) {
    if (body.includes(signal)) conceptualScore += 1;
  }

  for (const signal of reflectiveSignals) {
    if (body.includes(signal)) reflectiveScore += 1;
  }

  if (intuitiveScore > 0 && conceptualScore > 0) return 'REFLECTIVE_SCIENCE';
  if (reflectiveScore >= intuitiveScore && reflectiveScore >= conceptualScore)
    return 'REFLECTIVE_SCIENCE';
  if (intuitiveScore >= conceptualScore) return 'INTUITIVE';
  return 'CONCEPTUAL';
}

function inferTraceType(
  current: IntegratedTopicChunk,
): IntegratedTopicTraceType {
  const body =
    `${current.title} ${current.description} ${current.keyPoints.join(' ')}`.toLowerCase();

  if (body.includes('negation') || body.includes('negative')) return 'NEGATES';
  if (body.includes('sublat')) return 'SUBLATES';
  if (body.includes('mediate')) return 'MEDIATES';
  if (body.includes('reflect') || body.includes('shine')) return 'REFLECTS';
  return 'SPIRALS_TO';
}

function deriveTags(chunk: IntegratedTopicChunk): string[] {
  const body =
    `${chunk.title} ${chunk.description} ${chunk.keyPoints.join(' ')}`.toLowerCase();
  const tags = new Set<string>();

  if (body.includes('negation') || body.includes('negative'))
    tags.add('negation');
  if (body.includes('sublat')) tags.add('sublation');
  if (body.includes('reflect')) tags.add('reflection');
  if (body.includes('shine')) tags.add('shine');
  if (body.includes('mediate')) tags.add('mediation');
  if (body.includes('appearance')) tags.add('appearance');

  tags.add(chunk.dialecticalRole.toLowerCase());
  return [...tags];
}

function buildCypher(ir: IntegratedTopicMapIR): string {
  const statements: string[] = [];

  statements.push('// Triadic TopicMap Cypher IR (debug mode)');
  statements.push(
    '// Generated by src/relative/core/compiler/generate-essence-doctrine-cypher-ir.ts',
  );
  statements.push('');
  statements.push(
    'CREATE CONSTRAINT topicmap_source_id IF NOT EXISTS FOR (s:SourceText) REQUIRE s.id IS UNIQUE;',
  );
  statements.push(
    'CREATE CONSTRAINT topicmap_chunk_id IF NOT EXISTS FOR (c:TopicMapChunk) REQUIRE c.id IS UNIQUE;',
  );
  statements.push(
    'CREATE CONSTRAINT topicmap_kp_id IF NOT EXISTS FOR (k:KeyPoint) REQUIRE k.id IS UNIQUE;',
  );
  statements.push(
    'CREATE CONSTRAINT topicmap_triadic_id IF NOT EXISTS FOR (m:TriadicCategory) REQUIRE m.id IS UNIQUE;',
  );
  statements.push('');

  statements.push(
    `MERGE (protocol:TriadicProtocol {id: ${toCypherString(ir.id)}})`,
  );
  statements.push('SET protocol.mode = ' + toCypherString(ir.mode));
  statements.push('SET protocol.title = ' + toCypherString(ir.title));
  statements.push('SET protocol.section = ' + toCypherString(ir.section));
  statements.push(
    'SET protocol.generatedAt = ' + toCypherString(ir.metadata.generatedAt),
  );
  statements.push(
    'SET protocol.totalSources = ' + String(ir.metadata.totalSources),
  );
  statements.push(
    'SET protocol.totalChunks = ' + String(ir.metadata.totalChunks) + ';',
  );
  statements.push('');

  statements.push("MERGE (intuitive:TriadicCategory {id: 'INTUITIVE'})");
  statements.push("SET intuitive.title = 'Intuition';");
  statements.push("MERGE (conceptual:TriadicCategory {id: 'CONCEPTUAL'})");
  statements.push("SET conceptual.title = 'Concept';");
  statements.push(
    "MERGE (reflectiveScience:TriadicCategory {id: 'REFLECTIVE_SCIENCE'})",
  );
  statements.push(
    "SET reflectiveScience.title = 'Hegelian Science of Reflection';",
  );
  statements.push(
    'MERGE (intuitive)-[:SUBLATED_MEMBER_OF]->(reflectiveScience);',
  );
  statements.push(
    'MERGE (conceptual)-[:SUBLATED_MEMBER_OF]->(reflectiveScience);',
  );
  statements.push('MERGE (protocol)-[:ROOT_CATEGORY]->(reflectiveScience);');
  statements.push('MERGE (protocol)-[:MEMBER_CATEGORY]->(intuitive);');
  statements.push('MERGE (protocol)-[:MEMBER_CATEGORY]->(conceptual);');
  statements.push('');

  for (const source of ir.sourceDocuments) {
    statements.push(`MERGE (s:SourceText {id: ${toCypherString(source.id)}})`);
    statements.push('SET s.title = ' + toCypherString(source.title));
    statements.push('SET s.sourceFile = ' + toCypherString(source.sourceFile));
    statements.push('SET s.totalLines = ' + String(source.totalLines) + ';');
    statements.push(
      `MATCH (protocol:TriadicProtocol {id: ${toCypherString(ir.id)}})`,
    );
    statements.push(`MATCH (s:SourceText {id: ${toCypherString(source.id)}})`);
    statements.push('MERGE (protocol)-[:HAS_SOURCE]->(s);');

    for (const chunk of source.chunks) {
      statements.push(
        `MERGE (c:TopicMapChunk {id: ${toCypherString(chunk.id)}})`,
      );
      statements.push('SET c.title = ' + toCypherString(chunk.title));
      statements.push('SET c.sourceId = ' + toCypherString(chunk.sourceId));
      statements.push('SET c.sourceFile = ' + toCypherString(chunk.sourceFile));
      statements.push('SET c.lineStart = ' + String(chunk.lineRange.start));
      statements.push('SET c.lineEnd = ' + String(chunk.lineRange.end));
      statements.push(
        'SET c.description = ' + toCypherString(chunk.description),
      );
      statements.push('SET c.keyPoints = ' + toCypherArray(chunk.keyPoints));
      statements.push('SET c.tags = ' + toCypherArray(chunk.tags));
      statements.push('SET c.orderInSource = ' + String(chunk.orderInSource));
      statements.push('SET c.globalOrder = ' + String(chunk.globalOrder));
      statements.push(
        'SET c.dialecticalRole = ' + toCypherString(chunk.dialecticalRole),
      );
      statements.push(
        'SET c.sourceText = ' + toCypherString(chunk.sourceText) + ';',
      );
      statements.push(
        `MATCH (s:SourceText {id: ${toCypherString(source.id)}})`,
      );
      statements.push(
        `MATCH (c:TopicMapChunk {id: ${toCypherString(chunk.id)}})`,
      );
      statements.push('MERGE (s)-[:HAS_CHUNK]->(c);');
      statements.push(
        `MATCH (c:TopicMapChunk {id: ${toCypherString(chunk.id)}})`,
      );
      statements.push(
        `MATCH (cat:TriadicCategory {id: ${toCypherString(chunk.dialecticalRole)}})`,
      );
      statements.push('MERGE (c)-[:CLASSIFIED_AS]->(cat);');

      if (
        chunk.dialecticalRole === 'INTUITIVE' ||
        chunk.dialecticalRole === 'CONCEPTUAL'
      ) {
        statements.push(
          `MATCH (c:TopicMapChunk {id: ${toCypherString(chunk.id)}})`,
        );
        statements.push(
          "MATCH (root:TriadicCategory {id: 'REFLECTIVE_SCIENCE'})",
        );
        statements.push('MERGE (c)-[:SUBLATED_MEMBER_OF]->(root);');
      } else {
        statements.push(
          `MATCH (c:TopicMapChunk {id: ${toCypherString(chunk.id)}})`,
        );
        statements.push(
          "MATCH (root:TriadicCategory {id: 'REFLECTIVE_SCIENCE'})",
        );
        statements.push('MERGE (c)-[:MANIFESTS]->(root);');
      }

      for (let index = 0; index < chunk.keyPoints.length; index += 1) {
        const keyPoint = chunk.keyPoints[index] ?? '';
        const keyPointId = `${chunk.id}:kp:${index + 1}`;
        statements.push(
          `MERGE (kp:KeyPoint {id: ${toCypherString(keyPointId)}})`,
        );
        statements.push('SET kp.chunkId = ' + toCypherString(chunk.id));
        statements.push('SET kp.ordinal = ' + String(index + 1));
        statements.push('SET kp.text = ' + toCypherString(keyPoint) + ';');
        statements.push(
          `MATCH (c:TopicMapChunk {id: ${toCypherString(chunk.id)}})`,
        );
        statements.push(
          `MATCH (kp:KeyPoint {id: ${toCypherString(keyPointId)}})`,
        );
        statements.push('MERGE (c)-[:HAS_KEY_POINT]->(kp);');
      }
    }
  }

  for (const trace of ir.traces) {
    statements.push(
      `MATCH (a:TopicMapChunk {id: ${toCypherString(trace.fromChunkId)}})`,
    );
    statements.push(
      `MATCH (b:TopicMapChunk {id: ${toCypherString(trace.toChunkId)}})`,
    );
    statements.push(`MERGE (a)-[r:${trace.type}]->(b)`);
    statements.push('SET r.reason = ' + toCypherString(trace.reason) + ';');
  }

  for (const layer of ir.doctrine.layers) {
    statements.push(
      `MERGE (layer:ConsciousnessLayer {id: ${toCypherString(layer.id)}})`,
    );
    statements.push('SET layer.title = ' + toCypherString(layer.title));
    statements.push('SET layer.kind = ' + toCypherString(layer.kind));
    statements.push(
      'SET layer.description = ' + toCypherString(layer.description),
    );
    statements.push(
      'SET layer.chunkIds = ' + toCypherArray(layer.chunkIds) + ';',
    );
    statements.push(
      `MATCH (protocol:TriadicProtocol {id: ${toCypherString(ir.id)}})`,
    );
    statements.push(
      `MATCH (layer:ConsciousnessLayer {id: ${toCypherString(layer.id)}})`,
    );
    statements.push('MERGE (protocol)-[:HAS_LAYER]->(layer);');

    for (const chunkId of layer.chunkIds) {
      statements.push(
        `MATCH (chunk:TopicMapChunk {id: ${toCypherString(chunkId)}})`,
      );
      statements.push(
        `MATCH (layer:ConsciousnessLayer {id: ${toCypherString(layer.id)}})`,
      );
      statements.push('MERGE (chunk)-[:IN_LAYER]->(layer);');
    }
  }

  for (const relation of ir.doctrine.relations) {
    const relationshipType =
      relation.operator === 'SUBLATION' ? 'SUBLATES' : 'NEGATES';
    statements.push(
      `MATCH (a:ConsciousnessLayer {id: ${toCypherString(relation.fromLayerId)}})`,
    );
    statements.push(
      `MATCH (b:ConsciousnessLayer {id: ${toCypherString(relation.toLayerId)}})`,
    );
    statements.push(`MERGE (a)-[r:${relationshipType}]->(b)`);
    statements.push('SET r.operator = ' + toCypherString(relation.operator));
    statements.push(
      'SET r.description = ' + toCypherString(relation.description) + ';',
    );
  }

  return statements.join('\n');
}

async function main() {
  const here = path.dirname(fileURLToPath(import.meta.url));
  const packageRoot = path.resolve(here, '..', '..', '..', '..');

  const sourceBasePath = path.join(
    packageRoot,
    'src',
    'relative',
    'essence',
    'reflection',
    'essence',
    'sources',
  );

  const sourceSpecs: SourceSpec[] = [
    {
      id: 'source-essence',
      title: 'Essence',
      sourceFile: 'relative/essence/reflection/essence/sources/essence.txt',
      topicMap: essenceTopicMap,
    },
    {
      id: 'source-reflection',
      title: 'Reflection',
      sourceFile: 'relative/essence/reflection/essence/sources/reflection.txt',
      topicMap: reflectionTopicMap,
    },
    {
      id: 'source-shine',
      title: 'Shine',
      sourceFile: 'relative/essence/reflection/essence/sources/shine.txt',
      topicMap: shineTopicMap,
    },
    {
      id: 'source-identity',
      title: 'Identity',
      sourceFile: 'relative/essence/reflection/foundation/sources/identity.txt',
      topicMap: identityTopicMap,
    },
    {
      id: 'source-difference',
      title: 'Difference',
      sourceFile:
        'relative/essence/reflection/foundation/sources/difference.txt',
      topicMap: differenceTopicMap,
    },
    {
      id: 'source-contradiction',
      title: 'Contradiction',
      sourceFile:
        'relative/essence/reflection/foundation/sources/contradiction.txt',
      topicMap: contradictionTopicMap,
    },
  ];

  let globalOrder = 1;
  const traces: IntegratedTopicTrace[] = [];
  const sourceDocuments: IntegratedTopicMapIR['sourceDocuments'] = [];

  for (const sourceSpec of sourceSpecs) {
    const sourceAbsPath = path.join(packageRoot, 'src', sourceSpec.sourceFile);
    const fullSource = await fs.readFile(sourceAbsPath, 'utf8');
    const totalLines = fullSource.split(/\r?\n/).length;

    const chunks: IntegratedTopicChunk[] = sourceSpec.topicMap.map(
      (entry, index) => {
        const sourceText = extractChunkText(fullSource, entry.lineRange);
        const dialecticalRole = inferDialecticalRole(entry, sourceText);
        const chunk: IntegratedTopicChunk = {
          id: entry.id,
          title: entry.title,
          sourceId: sourceSpec.id,
          sourceFile: sourceSpec.sourceFile,
          lineRange: entry.lineRange,
          description: entry.description,
          keyPoints: entry.keyPoints,
          orderInSource: index + 1,
          globalOrder,
          sourceText,
          dialecticalRole,
          tags: [],
        };

        chunk.tags = deriveTags(chunk);
        globalOrder += 1;
        return chunk;
      },
    );

    for (let index = 0; index < chunks.length - 1; index += 1) {
      const current = chunks[index];
      const next = chunks[index + 1];
      if (!current || !next) continue;

      traces.push({
        fromChunkId: current.id,
        toChunkId: next.id,
        type: 'NEXT',
        reason: 'Sequential order in source text.',
      });

      traces.push({
        fromChunkId: current.id,
        toChunkId: next.id,
        type: inferTraceType(next),
        reason: `Dialectical transition inferred from ${next.id} semantics.`,
      });
    }

    sourceDocuments.push({
      id: sourceSpec.id,
      title: sourceSpec.title,
      sourceFile: sourceSpec.sourceFile,
      totalLines,
      chunks,
    });
  }

  traces.push({
    fromChunkId: 'idn-6',
    toChunkId: 'diff-2',
    type: 'LAYER_NEGATION',
    reason:
      'Principle of Reflective Science advances by negation from identity into difference.',
  });

  traces.push({
    fromChunkId: 'diff-15',
    toChunkId: 'ctr-1',
    type: 'SUBLATES',
    reason:
      'Law operation: identity and difference are sublated into contradiction.',
  });

  traces.push({
    fromChunkId: 'ctr-10',
    toChunkId: 'ref-2',
    type: 'SUBLATES',
    reason:
      'Principle and law are sublated into Reflection as layered negation science.',
  });

  const doctrine: ConsciousnessDoctrine = {
    layers: [
      {
        id: 'principle-reflective-science',
        title: 'Principle of Reflection (REFLECTIVE_SCIENCE)',
        kind: 'PRINCIPLE',
        description:
          'Hegelian starting determination where immediate and conceptual moments are sublated into reflected unity (REFLECTIVE_SCIENCE).',
        chunkIds: ['idn-3', 'idn-4', 'idn-6'],
      },
      {
        id: 'law-consciousness',
        title: 'Law of Reflection (Determinate Negation)',
        kind: 'LAW',
        description:
          'Determinate negation where identity and difference are driven into contradiction.',
        chunkIds: [
          'diff-13',
          'diff-14',
          'diff-15',
          'ctr-1',
          'ctr-4',
          'ctr-5',
          'ctr-10',
        ],
      },
      {
        id: 'science-reflection',
        title: 'Science of Reflection (Essence)',
        kind: 'SCIENCE',
        description:
          'Essence as a layered sequence of negation, sublation, and mediated return.',
        chunkIds: reflectionTopicMap.map((entry) => entry.id),
      },
    ],
    relations: [
      {
        fromLayerId: 'principle-reflective-science',
        toLayerId: 'law-consciousness',
        operator: 'SUBLATION',
        description: 'Principle sublates into particular lawful operation.',
      },
      {
        fromLayerId: 'law-consciousness',
        toLayerId: 'science-reflection',
        operator: 'SUBLATION',
        description: 'Lawful contradiction sequence sublates into Reflection.',
      },
      {
        fromLayerId: 'principle-reflective-science',
        toLayerId: 'science-reflection',
        operator: 'NEGATION',
        description:
          'Layered negation links the principle directly to reflection-science.',
      },
    ],
  };

  const ir: IntegratedTopicMapIR = {
    id: 'triadic-essence-debug-ir',
    mode: 'debug',
    title: 'Chunking/TopicMap IR â€” Intuitive-Conceptual-Reflective',
    section: 'Doctrine of Essence / Reflection / Foundation',
    sourceDocuments,
    traces,
    doctrine,
    triadicProtocol: {
      root: 'REFLECTIVE_SCIENCE',
      members: ['INTUITIVE', 'CONCEPTUAL'],
      relation: 'SUBLATED_MEMBERSHIP',
    },
    metadata: {
      totalSources: sourceDocuments.length,
      totalChunks: sourceDocuments.reduce(
        (sum, source) => sum + source.chunks.length,
        0,
      ),
      generatedAt: new Date().toISOString(),
    },
  };

  const parsed = IntegratedTopicMapIRSchema.safeParse(ir);
  if (!parsed.success) {
    const issueText = parsed.error.issues
      .map(
        (issue) =>
          `${issue.path.map(String).join('.') || '<root>'}: ${issue.message}`,
      )
      .join('\n');
    throw new Error(`TopicMapIR validation failed:\n${issueText}`);
  }

  const cypher = buildCypher(parsed.data);
  const outputDir = path.join(sourceBasePath, 'generated');
  await fs.mkdir(outputDir, { recursive: true });

  const cypherPath = path.join(outputDir, 'doctrine-topicmap-ir.cypher');
  const jsonPath = path.join(outputDir, 'doctrine-topicmap-ir.debug.json');

  await fs.writeFile(cypherPath, cypher, 'utf8');
  await fs.writeFile(jsonPath, JSON.stringify(parsed.data, null, 2), 'utf8');

  // eslint-disable-next-line no-console
  console.log(
    `Generated ${path.relative(packageRoot, cypherPath)} and ${path.relative(packageRoot, jsonPath)}.`,
  );
}

await main();
