import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

type WorkbookContract = {
  doctrineKey: string;
  doctrineName: string;
  workbookPath: string;
  boundaryRules: string[];
  rejectionCodes: string[];
};

const defaultRejectionCodes = [
  'RJ_GENESIS_UNSAT',
  'RJ_MORPH_ADMISSIBILITY_FAIL',
  'RJ_CONTEXT_INVALID',
  'RJ_PATH_BROKEN',
  'RJ_CONTRADICTION_UNRESOLVED',
  'RJ_GROUND_MISSING',
];

function toPascalCase(value: string): string {
  const normalized = value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
    .split(/\s+/)
    .filter(Boolean)
    .map((part) => part[0]?.toUpperCase() + part.slice(1))
    .join('');

  if (!normalized) {
    return 'Workbook';
  }

  if (/^[0-9]/.test(normalized)) {
    return `N${normalized}`;
  }

  return normalized;
}

async function collectWorkbookFiles(rootDir: string): Promise<string[]> {
  const results: string[] = [];

  async function walk(currentDir: string): Promise<void> {
    const entries = await fs.readdir(currentDir, { withFileTypes: true });
    await Promise.all(
      entries.map(async (entry) => {
        const absolutePath = path.join(currentDir, entry.name);
        if (entry.isDirectory()) {
          await walk(absolutePath);
          return;
        }

        if (/^[A-Z0-9-]+-COMPILER-V2-WORKBOOK\.md$/.test(entry.name)) {
          results.push(absolutePath);
        }
      }),
    );
  }

  await walk(rootDir);
  return results.sort((a, b) => a.localeCompare(b));
}

function extractBulletBlock(
  markdown: string,
  sectionHeading: RegExp,
): string[] {
  const lines = markdown.split(/\r?\n/);
  const values: string[] = [];
  let inBlock = false;

  for (const line of lines) {
    if (!inBlock && sectionHeading.test(line)) {
      inBlock = true;
      continue;
    }

    if (inBlock && /^##\s+/.test(line)) {
      break;
    }

    if (!inBlock) {
      continue;
    }

    const bullet = line.match(/^\s*-\s+(.+)$/);
    if (!bullet) {
      continue;
    }

    const content = bullet[1]?.trim();
    if (content) {
      values.push(content.replace(/^`(.+)`$/, '$1'));
    }
  }

  return values;
}

function parseWorkbookContract(
  markdown: string,
  absolutePath: string,
  packageRoot: string,
): WorkbookContract {
  const fileName = path.basename(absolutePath);
  const doctrineKey = fileName.replace(/-COMPILER-V2-WORKBOOK\.md$/, '');
  const doctrineName = toPascalCase(doctrineKey);
  const workbookPath = path
    .relative(packageRoot, absolutePath)
    .replace(/\\/g, '/');

  const boundaryRules = extractBulletBlock(
    markdown,
    /^##\s+Non-negotiable boundary\s*$/i,
  );

  const rejectionCodes = extractBulletBlock(
    markdown,
    /^##\s+Rejection taxonomy\s*\(mandatory\)\s*$/i,
  ).filter((line) => /^RJ_[A-Z0-9_]+$/.test(line));

  return {
    doctrineKey,
    doctrineName,
    workbookPath,
    boundaryRules,
    rejectionCodes:
      rejectionCodes.length > 0 ? rejectionCodes : [...defaultRejectionCodes],
  };
}

function renderContractScaffold(contract: WorkbookContract): string {
  const functionName = `compile${contract.doctrineName}WorkbookJudgments`;
  const candidateTypeName = `${contract.doctrineName}WorkbookCandidate`;
  const rejectionTypeName = `${contract.doctrineName}WorkbookRejectionCode`;
  const resultTypeName = `${contract.doctrineName}WorkbookCompilationResult`;
  const constName = `${contract.doctrineKey}_COMPILER_V2_CONTRACT`;

  const rejectionUnion = contract.rejectionCodes
    .map((code) => `'${code}'`)
    .join(' | ');

  const boundaryLines = contract.boundaryRules
    .map((rule) => `    ${JSON.stringify(rule)},`)
    .join('\n');
  const rejectionLines = contract.rejectionCodes
    .map((code) => `    '${code}',`)
    .join('\n');

  return [
    '// Generated by src/relative/core/compiler/generate-compiler-from-workbooks.ts',
    '',
    `export const ${constName} = {`,
    `  doctrine: ${JSON.stringify(contract.doctrineName)},`,
    `  workbookPath: ${JSON.stringify(contract.workbookPath)},`,
    '  boundaryRules: [',
    boundaryLines,
    '  ],',
    '  rejectionCodes: [',
    rejectionLines,
    '  ],',
    '} as const;',
    '',
    `export type ${rejectionTypeName} = ${rejectionUnion};`,
    '',
    `export type ${candidateTypeName} = {`,
    '  id: string;',
    '  generated: boolean;',
    '  admissibleMorph: boolean;',
    '  validPath: boolean;',
    '  contradicted: boolean;',
    '  evidence: string[];',
    '};',
    '',
    `export type ${resultTypeName} = {`,
    `  surviving: ${candidateTypeName}[];`,
    `  blessed: ${candidateTypeName}[];`,
    '  rejections: Array<{',
    '    candidateId: string;',
    `    code: ${rejectionTypeName};`,
    "    phase: 'reflection';",
    '    evidence: string[];',
    '    explanation: string;',
    '  }>;',
    '};',
    '',
    `export function ${functionName}(`,
    `  candidates: ${candidateTypeName}[],`,
    `): ${resultTypeName} {`,
    `  const surviving = candidates.filter(`,
    '    (candidate) =>',
    '      candidate.generated &&',
    '      candidate.admissibleMorph &&',
    '      candidate.validPath &&',
    '      !candidate.contradicted,',
    '  );',
    '',
    '  const blessed = [...surviving];',
    '',
    '  const rejections = candidates',
    '    .filter((candidate) => !surviving.some((entry) => entry.id === candidate.id))',
    '    .map((candidate) => ({',
    '      candidateId: candidate.id,',
    `      code: 'RJ_PATH_BROKEN' as ${rejectionTypeName},`,
    "      phase: 'reflection' as const,",
    '      evidence: candidate.evidence,',
    '      explanation: `Candidate ${candidate.id} did not satisfy workbook survivability gates.`,',
    '    }));',
    '',
    '  return { surviving, blessed, rejections };',
    '}',
    '',
  ].join('\n');
}

function renderManifest(contracts: WorkbookContract[]): string {
  const imports = contracts
    .map((contract) => {
      const localName = `${contract.doctrineKey.toLowerCase()}Contract`;
      const fileName = `compile-${contract.doctrineKey.toLowerCase()}-from-workbook`;
      const exportName = `${contract.doctrineKey}_COMPILER_V2_CONTRACT`;
      return `import { ${exportName} as ${localName} } from './${fileName}';`;
    })
    .join('\n');

  const contractRefs = contracts
    .map((contract) => `  ${contract.doctrineKey.toLowerCase()}Contract,`)
    .join('\n');

  return [
    '// Generated by src/relative/core/compiler/generate-compiler-from-workbooks.ts',
    imports,
    '',
    'export const workbookCompilerContracts = [',
    contractRefs,
    '] as const;',
    '',
  ].join('\n');
}

async function main(): Promise<void> {
  const here = path.dirname(fileURLToPath(import.meta.url));
  const packageRoot = path.resolve(here, '..', '..', '..', '..');
  const sourceRoot = path.join(packageRoot, 'src', 'relative');
  const generatedDir = path.join(
    packageRoot,
    'src',
    'relative',
    'core',
    'compiler',
    'generated',
  );

  const workbookFiles = await collectWorkbookFiles(sourceRoot);
  const contracts: WorkbookContract[] = [];

  for (const workbookFile of workbookFiles) {
    const markdown = await fs.readFile(workbookFile, 'utf8');
    contracts.push(parseWorkbookContract(markdown, workbookFile, packageRoot));
  }

  await fs.mkdir(generatedDir, { recursive: true });

  await Promise.all(
    contracts.map(async (contract) => {
      const fileName = `compile-${contract.doctrineKey.toLowerCase()}-from-workbook.ts`;
      const filePath = path.join(generatedDir, fileName);
      const content = renderContractScaffold(contract);
      await fs.writeFile(filePath, content, 'utf8');
    }),
  );

  const manifestPath = path.join(generatedDir, 'workbook-compiler-manifest.ts');
  await fs.writeFile(manifestPath, renderManifest(contracts), 'utf8');

  console.log(
    `Generated ${contracts.length} workbook compiler scaffold modules and manifest at ${path.relative(packageRoot, generatedDir)}.`,
  );
}

await main();
